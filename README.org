#+title: Emacs-enhanced - Replacement defuns for major functional improvements
#+author: James Dyer
#+date: 2024
#+description: Emacs elisp defuns replacing or enhancing major external packages.
#+startup: showall
#+todo: TODO DOING | DONE
#+property: header-args :tangle ~/.emacs.d/Emacs-enhanced/init.el

#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
#+end_src

* Introduction

A conversion of major Emacs packages / functions, especially ones that I rely on to single defuns to try avoid the dependence of external packages.

It is also a general comment on how I have moved to more a vanilla based Emacs setup and relying much less on external packages as I think I now have enough elisp knowledge to replace a lot of them!

Perfect for lightweight usage in VMs or basic tasks.

Used in concert with https://github.com/captainflasmr/Emacs-core

* Whats New

** <2024-12-18>

Added abbrev to replace tempel

** <2024-12-17>

fix(README): add workaround for missing ssh-askpass in Emacs with vc-dir mode

- Documented steps to resolve the issue where pushing to GitHub from Emacs using vc-dir mode fails due to missing ssh-askpass.
- Added instructions for installing `openssh-askpass` and creating a symbolic link to `/usr/lib/ssh/ssh-askpass`.
- Mentioned the potential QFSFileEngine error during `git push` with workaround applied.

This commit adds clarity for users encountering the `Permission denied (publickey)` issue and provides a temporary fix until a better solution is implemented.

* Kanban

Here is a kanban of the features that will be (hopefully) converted to core/enhanced Emacs features and visually demonstrating their current status via a kanban board

#+begin: kanban :layout ("..." . 50) :scope nil :range ("TODO" . "DONE") :sort "O" :depth 3 :match "roadmap" :compressed t
| TODO                               | DOING    | DONE                    |
|------------------------------------+----------+-------------------------|
| [[file:README.org::*selected-window-accent-mode][selected-window-accent-mode]]        | [[file:README.org::*embark][embark]]   | [[file:README.org::*minibuffer completion][minibuffer completion]]   |
| [[file:README.org::*htmlize][htmlize]]                            | [[file:README.org::*deadgrep][deadgrep]] | [[file:README.org::*ace-window][ace-window]]              |
| [[file:README.org::*image-dired][image-dired]]                        | [[file:README.org::*popper][popper]]   | [[file:README.org::*recentf-open][recentf-open]]            |
| [[file:README.org::*corfu / company completion][corfu / company completion]]         |          | [[file:README.org::*rainbow-mode][rainbow-mode]]            |
| [[file:README.org::*spelling][spelling]]                           |          | [[file:README.org::*visual-fill-column-mode][visual-fill-column-mode]] |
| [[file:README.org::*shell][shell]]                              |          | [[file:README.org::*find-name-dired][find-name-dired]]         |
| [[file:README.org::*capf-autosuggest][capf-autosuggest]]                   |          | [[file:README.org::*magit][magit]]                   |
| [[file:README.org::*org-capture][org-capture]]                        |          | [[file:README.org::*tempel][tempel]]                  |
| [[file:README.org::*DWIM script integration][DWIM script integration]]            |          |                         |
| [[file:README.org::*org-agenda][org-agenda]]                         |          |                         |
| [[file:README.org::*kurecolor][kurecolor]]                          |          |                         |
| [[file:README.org::*Ada][Ada]]                                |          |                         |
| [[file:README.org::*transients][transients]]                         |          |                         |
| [[file:README.org::*my/transient-outlining-and-folding][my/transient-outlining-and-folding]] |          |                         |
| [[file:README.org::*my/prog-folding][my/prog-folding]]                    |          |                         |
#+end:

* Roadmap                                                           :roadmap:

Here are the features that will be (hopefully) converted to core.

** DONE minibuffer completion

fido-mode enabled replacing:

- vertico
- marginalia

but also require the following for exiting a forced completion:

#+begin_src elisp
(defun my-icomplete-exit-minibuffer-with-input ()
  "Exit the minibuffer with the current input, without forcing completion."
  (interactive)
  (exit-minibuffer))
#+end_src

** DONE ace-window
CLOSED: [2024-12-08 Sun 13:53]

Solved with the code below:

#+begin_src elisp
(defun my/quick-window-jump ()
  "Jump to a window by typing its assigned character label.
If there are only two windows, jump directly to the other window."
  (interactive)
  (let* ((window-list (window-list nil 'no-mini)))
    (if (= (length window-list) 2)
        ;; If there are only two windows, switch to the other one directly.
        (select-window (other-window-for-scrolling))
      ;; Otherwise, show the key selection interface.
      (let* ((my/quick-window-overlays nil)
             (sorted-windows (sort window-list
                                   (lambda (w1 w2)
                                     (let ((edges1 (window-edges w1))
                                           (edges2 (window-edges w2)))
                                       (or (< (car edges1) (car edges2))
                                           (and (= (car edges1) (car edges2))
                                                (< (cadr edges1) (cadr edges2))))))))
             (window-keys (seq-take '("j" "k" "l" ";" "a" "s" "d" "f")
                                    (length sorted-windows)))
             (window-map (cl-pairlis window-keys sorted-windows)))
        (setq my/quick-window-overlays
              (mapcar (lambda (entry)
                        (let* ((key (car entry))
                               (window (cdr entry))
                               (start (window-start window))
                               (overlay (make-overlay start start (window-buffer window))))
                          (overlay-put overlay 'after-string 
                                       (propertize (format "[%s]" key)
                                                   'face '(:foreground "white" :background "blue" :weight bold)))
                          (overlay-put overlay 'window window)
                          overlay))
                      window-map))
        (let ((key (read-key (format "Select window [%s]: " (string-join window-keys ", ")))))
          (mapc #'delete-overlay my/quick-window-overlays)
          (setq my/quick-window-overlays nil)
          (when-let ((selected-window (cdr (assoc (char-to-string key) window-map))))
            (select-window selected-window)))))))
#+end_src

** DONE recentf-open
CLOSED: [2024-12-09 Mon 09:22]

Given recentf-open was introduced in 29.1 it would probably be straightforward to create a general recentf passing through completing read.  Probably just copy what has been put into recentf.el

Solved with the code below:

#+begin_src elisp
(defun my/recentf-open (file)
  "Prompt for FILE in `recentf-list' and visit it.
Enable `recentf-mode' if it isn't already."
  (interactive
   (list
    (progn (unless recentf-mode (recentf-mode 1))
           (completing-read "Open recent file: " recentf-list nil t))))
  (when file
    (funcall recentf-menu-action file)))
#+end_src

** DONE rainbow-mode
CLOSED: [2024-12-09 Mon 10:50]

Solved with the code below:

#+begin_src elisp
(defun my/rainbow-mode ()
  "Overlay colors represented as hex values in the current buffer."
  (interactive)
  (remove-overlays (point-min) (point-max))
  (let ((hex-color-regex "#[0-9a-fA-F]\\{3,6\\}"))
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward hex-color-regex nil t)
        (let* ((color (match-string 0))
               (overlay (make-overlay (match-beginning 0) (match-end 0))))
          (if (string-greaterp color "#888888")
              (overlay-put overlay 'face `(:background ,color :foreground "black"))
            (overlay-put overlay 'face `(:background ,color :foreground "white"))))))))
;;
(defun my/rainbow-mode-clear ()
  "Remove all hex color overlays in the current buffer."
  (interactive)
  (remove-overlays (point-min) (point-max)))
#+end_src

** DONE visual-fill-column-mode
CLOSED: [2024-12-09 Mon 13:50]

Solved with the code below:

#+begin_src elisp
(defun toggle-centered-buffer ()
  "Toggle center alignment of the buffer by adjusting window margins based on the fill-column."
  (interactive)
  (let* ((current-margins (window-margins))
         (margin (if (or (equal current-margins '(0 . 0))
                         (null (car (window-margins))))
                     (/ (- (window-total-width) fill-column) 2)
                   0)))
    (visual-line-mode 1)
    (set-window-margins nil margin margin)))
#+end_src

** DONE find-name-dired
CLOSED: [2024-12-18 Wed 09:27]

Currently find file type jump key functionality for core is just find-name-dired but probably better to have a more flexible version that can still use =find-name-dired= but if ripgrep exists or even find then present those options.  This will then potentially be a more modern approach.

Being solved with the following code:

#+begin_src elisp
(defun my/find-file ()
  "Find file from current directory in many different ways."
  (interactive)
  (let* ((find-options (delq nil
                             (list (when (executable-find "find")
                                     '("find -type f -printf \"$PWD/%p\\0\"" . :string))
                                   (when (executable-find "fd")
                                     '("fd --absolute-path --type f -0" . :string))
                                   (when (executable-find "rg")
                                     '("rg --follow --files --null" . :string))
                                   (when (fboundp 'find-name-dired)
                                     '("find-name-dired" . :command)))))
         (selection (completing-read "Select: " find-options))
         file-list
         file)
    (pcase (alist-get selection find-options nil nil #'string=)
      (:command
       (call-interactively (intern selection)))
      (:string
       (setq file-list (split-string (shell-command-to-string selection) "\0" t))
       (setq file (completing-read
                   (format "Find file in %s: "
                           (abbreviate-file-name default-directory))
                   file-list))))
    (when file (find-file (expand-file-name file)))))
#+end_src

** DONE magit
CLOSED: [2024-12-18 Wed 09:28]

Replaced by built-in VC

Just need to be able to push using ssh

The following instructions seem to work for now, but should really be doing a little better:

Are you getting the following issue when trying to push to github from Emacs in vc-dir mdoe?
  
#+begin_src 
Running "git push"...
ssh_askpass: exec(/usr/lib/ssh/ssh-askpass): No such file or directory
git@github.com: Permission denied (publickey).
fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.
#+end_src

Well the ssh-askpass is not installed and doesn't exist in =/usr/lib/ssh/ssh-askpass=

Is there a way to point to a different name in Emacs?, not sure

But perform the following as a current workaround
  
Install the following:

=openssh-askpass=

Which make available the following:
  
/usr/bin/qt4-ssh-askpass

Emacs is looking for:

/usr/lib/ssh/ssh-askpass

So why not provide a symbolic link as root!?, seems to work:

#+begin_src 
  su -
  cd /usr/lib/ssh
  ln -s /usr/bin/qt4-ssh-askpass ssh-askpass
#+end_src

Although still raises the following:
  
#+begin_src
  Running "git push"...
  ErrorHandler::Throw - warning: QFSFileEngine::open: No file name specified file:  line: 0 function: 
  To github.com:captainflasmr/Emacs-enhanced.git
  6735e12..4766e6c  main -> main
#+end_src

** DONE tempel
CLOSED: [2024-12-18 Wed 09:26]

I use pretty simple, no yassnippet complexity here, so maybe I can adapt abbrev with some predefined functions for the most common completion replacements?

** DOING embark

I am not using too many aspects mainly the following:

- copy command - probably easy to replicate

Solved with the code below:

#+begin_src elisp
(defun my-icomplete-copy-candidate ()
  "Copy the current Icomplete candidate to the kill ring."
  (interactive)
  (let ((candidate (car completion-all-sorted-completions)))
    (when candidate
      (kill-new (substring-no-properties candidate))
      (abort-recursive-edit))))
;;
(define-key minibuffer-local-completion-map (kbd "C-c ,") 'my-icomplete-copy-candidate)
#+end_src
  
- collect
- export

** DOING deadgrep

Would rgrep be potentially good enough?, maybe, or maybe pull on ripgrep through a simple interface and re-use =grep-mode= so essentially it will look just like rgrep output except with more information about the ripgrep search in the style of deadgrep, for example:

- directory
- search term
- glob

and like deadgrep have some local keybindings that can input the directory, search-term or glob

Being solved with the following code:

#+begin_src elisp
(defun my/grep (search-term &optional directory glob)
  "Run ripgrep (rg) with SEARCH-TERM and optionally DIRECTORY and GLOB.
  If ripgrep is unavailable, fall back to Emacs's rgrep command. Highlights SEARCH-TERM in results.
  By default, only the SEARCH-TERM needs to be provided. If called with a
  universal argument, DIRECTORY and GLOB are prompted for as well."
  (interactive
   (let ((univ-arg current-prefix-arg))
     (list
      (read-string "Search for: ")
      (when univ-arg (read-directory-name "Directory: "))
      (when univ-arg (read-string "File pattern (glob, default: ): " nil nil "")))))
  (let* ((directory (expand-file-name (or directory default-directory)))
         (glob (or glob ""))
         (buffer-name "*grep*"))
    (if (executable-find "rg")
        (let* ((rg-command (format "rg --color=never --max-columns=500 --column --line-number --no-heading --smart-case -e %s --glob %s %s"
                                   (shell-quote-argument search-term)
                                   (shell-quote-argument glob)
                                   directory))
               (debug-output (shell-command-to-string (format "rg --debug --files %s" directory)))
               (ignore-files (when (string-match "ignore file: \\(.*?\\.ignore\\)" debug-output)
                               (match-string 1 debug-output)))
               (raw-output (shell-command-to-string rg-command))
               (formatted-output
                (when (not (string-empty-p raw-output))
                  (concat
                   (format "[s] Search:    %s\n[d] Directory: %s\n" search-term directory)
                   (format "[o] Glob:      %s\n" glob)
                   (if ignore-files (format "%s\n" ignore-files) "")
                   "\n"
                   (replace-regexp-in-string (concat "\\(^" (regexp-quote directory) "\\)") "./" raw-output)))))
          (when (get-buffer buffer-name)
            (kill-buffer buffer-name))
          (with-current-buffer (get-buffer-create buffer-name)
            (setq default-directory directory)
            (erase-buffer)
            (insert (or formatted-output "No results found."))
            (insert "\nripgrep finished.")
            (goto-char (point-min))
            (when formatted-output
              (let ((case-fold-search t))
                (while (search-forward search-term nil t)
                  (overlay-put (make-overlay (match-beginning 0) (match-end 0))
                               'face '(:slant italic :weight bold :underline t)))))
            (grep-mode)
            (pop-to-buffer buffer-name)
            (goto-char (point-min))
            (message "ripgrep finished.")))
      (progn
        (setq default-directory directory)
        (message (format "%s : %s : %s" search-term glob directory))
        (rgrep search-term  (if (string= "" glob) "*" glob) directory)))
    (with-current-buffer "*grep*"
      (local-set-key (kbd "d") (lambda () 
                                 (interactive)
                                 (my/grep search-term 
                                          (read-directory-name "New search directory: ")
                                          glob)))
      (local-set-key (kbd "s") (lambda () 
                                 (interactive)
                                 (my/grep (read-string "New search term: ")
                                          directory
                                          glob)))
      (local-set-key (kbd "o") (lambda () 
                                 (interactive)
                                 (my/grep search-term
                                          directory
                                          (read-string "New glob: "))))
      (local-set-key (kbd "g") (lambda () 
                                 (interactive)
                                 (my/grep search-term directory glob))))))
#+end_src

*** BUGS

**** FIXED rgrep fallback doesn't have local keys option of "d" "s" "g" which would be a nice improvement

** DOING popper

Mainly used for popping and popping out shells, I'm sure I can code up an alternative solution here if I need to.

Testing the following implementation:

#+begin_src elisp
(defvar my/popper-current-popup nil
  "Stores the currently active popup buffer for quick toggle.")
;;
(defun my/popper-toggle-popup ()
  "Toggle visibility of pop-up buffers.
Pop-ups are identified by their names and certain buffer modes.
When toggled, the function displays the next available pop-up
buffer or hides currently displayed pop-ups. Stores the last
active popup in `my/popper-current-popup`."
  (interactive)
  (let* ((popup-patterns '("\\*Help\\*" "\\*eshell\\*" "\\*eldoc\\*"))
         (popup-buffers (seq-filter (lambda (buf)
                                      (let ((bufname (buffer-name buf)))
                                        (seq-some (lambda (pattern)
                                                    (string-match-p pattern bufname))
                                                  popup-patterns)))
                                    (buffer-list)))
         (current-popup (car (seq-filter (lambda (win)
                                           (member (window-buffer win) popup-buffers))
                                         (window-list)))))

    (if current-popup
        ;; If a pop-up buffer is currently visible, bury it.
        (let ((buf (window-buffer current-popup)))
          (delete-window current-popup)
          (bury-buffer buf)
          (setq my/popper-current-popup nil) ;; Clear the currently tracked popup.
          (message "Hid pop-up buffer: %s" (buffer-name buf)))
      ;; Otherwise, display the first available pop-up buffer.
      (if popup-buffers
          (let ((buf (car popup-buffers)))
            (pop-to-buffer buf
                           '(display-buffer-at-bottom
                             (inhibit-same-window . t)
                             (window-height . 0.3)))
            (setq my/popper-current-popup buf) ;; Store the displayed popup buffer.
            (message "Displayed pop-up buffer: %s" (buffer-name buf)))
        (message "No pop-up buffers to display!")))))
;;
(defun my/popper-toggle-current ()
  "Toggle visibility of the last active popup buffer (`my/popper-current-popup`).
If the popup is visible, hide it. If the popup is not visible, restore it."
  (interactive)
  (if (and my/popper-current-popup (buffer-live-p my/popper-current-popup))
      (if (get-buffer-window my/popper-current-popup)
          (progn
            (delete-window (get-buffer-window my/popper-current-popup))
            (message "Hid active popup buffer: %s" (buffer-name my/popper-current-popup)))
        (pop-to-buffer my/popper-current-popup
                       '(display-buffer-at-bottom
                         (inhibit-same-window . t)
                         (window-height . 0.3)))
        (message "Restored active popup buffer: %s" (buffer-name my/popper-current-popup)))
    ;; If no valid currently tracked popup:
    (message "No active popup buffer to toggle.")))
;;
;; Cycle through popups or show the next popup.
(global-set-key (kbd "C-c l") #'my/popper-toggle-popup)
;;
;; Toggle the currently selected popup.
(global-set-key (kbd "C-c p") #'my/popper-toggle-current)
#+end_src

** TODO selected-window-accent-mode

My package of highlighting the selected window/tabs, which actually I find very useful and of course due to my familiarity I could code up a more simple version.

** TODO htmlize

Go through the Emacs export mechanism instead and open separate browser window, refreshing when exported each time?

** TODO image-dired

Copy over functionality, no real external things, its just is it valuable given how little I use it? 

** TODO corfu / company completion

Can probably live without, as tab completion is probably fine

** TODO spelling

The core is using hunspell, flyspell which works generally pretty well, libreoffice will pretty much always be available or easily installable so hunspell will probably be always available.

I like jinx as it is fast and efficient.

powerthesaurus I don't use that often.

writegood-mode is a favourite, but I could probably live without it.

** TODO shell

Can I bring in cape-history into eshell/shell, the main issue is the inline fish type completion which I may be able to live without, but it is really fast and convenient!

** TODO capf-autosuggest

Some elisp for some simple predictive inline completion, maybe take a look at how capf-autosuggest does it.

** TODO org-capture

I think we can already move to core

** TODO DWIM script integration

Should be almost a straightforward copy, just need to consider which bash scripts I copy across, if any

** TODO org-agenda

I think we can already move to core

** TODO kurecolor

Add some elisp with the requisite regex-search and elisp colour calls, I have achieved this in the past, before I found the more convenient option of kurecolor

** TODO Ada

Unfortunately this may be the only elisp package that I may need to bake into this whole concept.  Current ada-mode isn't supported out of the box in Emacs, it is suggested to use the AdaCore ada-mode but that is a pain to compile (mainly due to trying to install gnatcoll), I have found the old ada mode used by Emacs for that adequate, so this may need to be separately downloaded and baked in.

These is also the potential to use ada-mode-lite and leverage eglot for the rest.

** TODO transients

Convert all transients which rely on Emacs 28 implementation of built-in transients.  The same can be achieved comfortably with a simple menu to stdout and read key type system.

*** TODO my/transient-outlining-and-folding

Transient menu for outline-mode.

*** TODO my/prog-folding

Enable and configure outline minor mode for code folding.  This function sets up the outline minor mode tailored for programming modes based on basic space / tab indentation.

* TODO Features that won't be converted to core

** TODO calendar / calfw

** TODO themes

** TODO ox-hugo

** TODO eglot

Not too much I can do about this, however I could apply some =etag= replacement functionality, but it really isn't the same.
