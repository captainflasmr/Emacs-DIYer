#+title: Emacs-enhanced - Replacement defuns for major functional improvements
#+author: James Dyer
#+date: 2024
#+description: Emacs elisp defuns replacing or enhancing major external packages.
#+startup: showall
#+todo: TODO DOING | DONE
#+property: header-args :tangle no

* Introduction

A stripped-down Emacs configuration that avoids external packages, perfect for lightweight usage in VMs or basic tasks.

* Roadmap                                                           :roadmap:

Here are the features that will be (hopefully) converted to core.

** DONE ace-window
CLOSED: [2024-12-08 Sun 13:53]

Solved with the code below:

#+begin_src elisp
(defun my/quick-window-jump ()
  "Jump to a window by typing its assigned character label.
Windows are labeled starting from the top-left window and proceeding top to bottom, then left to right."
  (interactive)
  (let* ((my/quick-window-overlays nil) ; Temporary list for overlays
         ;; Sort windows by position (top-to-bottom, left-to-right)
         (window-list (sort (window-list nil 'no-mini)
                            (lambda (w1 w2)
                              (let ((edges1 (window-edges w1))
                                    (edges2 (window-edges w2)))
                                (or (< (car edges1) (car edges2))
                                    (and (= (car edges1) (car edges2))
                                         (< (cadr edges1) (cadr edges2))))))))
         ;; Assign key labels to windows
         (window-keys (seq-take '("j" "k" "l" ";" "a" "s" "d" "f")
                                (length window-list)))
         (window-map (cl-pairlis window-keys window-list))) ; Create map of keys to windows
    ;; Add overlays to display key labels in each window
    (setq my/quick-window-overlays
          (mapcar (lambda (entry)
                    (let* ((key (car entry))
                           (window (cdr entry))
                           (start (window-start window)) ; Start position of window
                           (overlay (make-overlay start start (window-buffer window)))) ; Create overlay
                      (overlay-put overlay 'after-string  ; Add a visual label
                                   (propertize (format "[%s]" key)
                                               'face '(:foreground "white" 
                                                                   :background "blue" 
                                                                   :weight bold)))
                      (overlay-put overlay 'window window) ; Associate overlay with window
                      overlay))
                  window-map))
    ;; Read key input from user
    (let ((key (read-key (format "Select window [%s]: " (string-join window-keys ", ")))))
      ;; Clear overlays and reset
      (mapc #'delete-overlay my/quick-window-overlays)
      (setq my/quick-window-overlays nil)
      ;; Select window based on key or show error
      (when-let ((selected-window (cdr (assoc (char-to-string key) window-map))))
        (select-window selected-window)))))
#+end_src

** DONE recentf-open
CLOSED: [2024-12-09 Mon 09:22]

Given recentf-open was introduced in 29.1 it would probably be straightforward to create a general recentf passing through completing read.  Probably just copy what has been put into recentf.el

Solved with the code below:

#+begin_src elisp
(defun my/recentf-open (file)
  "Prompt for FILE in `recentf-list' and visit it.
Enable `recentf-mode' if it isn't already."
  (interactive
   (list
    (progn (unless recentf-mode (recentf-mode 1))
           (completing-read (format-prompt "Open recent file" nil)
                            recentf-list nil t))))
  (when file
    (funcall recentf-menu-action file)))
#+end_src

** DONE rainbow-mode
CLOSED: [2024-12-09 Mon 10:50]

Solved with the code below:

#+begin_src elisp
(defun my/rainbow-mode ()
  "Overlay colors represented as hex values in the current buffer."
  (interactive)
  (remove-overlays (point-min) (point-max))
  (let ((hex-color-regex "#[0-9a-fA-F]\\{3,6\\}"))
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward hex-color-regex nil t)
        (let* ((color (match-string 0))
               (overlay (make-overlay (match-beginning 0) (match-end 0))))
          (if (string-greaterp color "#888888")
              (overlay-put overlay 'face `(:background ,color :foreground "black"))
            (overlay-put overlay 'face `(:background ,color :foreground "white"))))))))
;;
(defun my/rainbow-mode-clear ()
  "Remove all hex color overlays in the current buffer."
  (interactive)
  (remove-overlays (point-min) (point-max)))
#+end_src

** DOING embark

I am not using too many aspects mainly the following:

- copy command - probably easy to replicate

Solved with the code below:

#+begin_src elisp
(defun my-icomplete-copy-candidate ()
  "Copy the current Icomplete candidate to the kill ring."
  (interactive)
  (let ((candidate (car completion-all-sorted-completions)))
    (when candidate
      (kill-new (substring-no-properties candidate))
      (abort-recursive-edit))))
;;
(define-key minibuffer-local-completion-map (kbd "C-c ,") 'my-icomplete-copy-candidate)
#+end_src
  
- collect
- export

** DONE visual-fill-column-mode
CLOSED: [2024-12-09 Mon 13:50]

Solved with the code below:

#+begin_src elisp
(defun toggle-centered-buffer ()
  "Toggle center alignment of the buffer by adjusting window margins based on the fill-column."
  (interactive)
  (let* ((current-margins (window-margins))
         (margin (if (or (equal current-margins '(0 . 0))
                         (null (car (window-margins))))
                     (/ (- (window-total-width) fill-column) 2)
                   0)))
    (visual-line-mode 1)
    (set-window-margins nil margin margin)))
#+end_src

** DOING deadgrep

Would rgrep be potentially good enough?, maybe, or maybe pull on ripgrep through a simple interface.

Being solved with the following code:

#+begin_src elisp
(defun my/grep (search-term directory glob)
  "Run ripgrep (rg) with SEARCH-TERM in DIRECTORY and GLOB if available,
otherwise fall back to Emacs's rgrep command. Highlights SEARCH-TERM in results."
  (interactive
   (list
    (read-string "Search for: ")
    (read-directory-name "Directory: ")
    (read-string "File pattern (glob, default: *): " nil nil "*")))
  (let ((directory (expand-file-name directory))) ;; Expand directory to absolute path
    (if (executable-find "rg")
        ;; Use ripgrep if available
        (let* ((buffer-name "*my-rg-results*")
               (home-dir (expand-file-name "~"))
               (rg-command (format "rg --color=never --column --line-number --no-heading --smart-case -e %s --glob %s %s"
                                   (shell-quote-argument search-term)
                                   (shell-quote-argument glob)
                                   directory))
               (raw-output (shell-command-to-string rg-command))
               (formatted-output
                (if (not (string-empty-p raw-output))
                    ;; Replace absolute path with relative path or "./"
                    (replace-regexp-in-string (concat "\\(^" (regexp-quote directory) "\\)") "./" raw-output)
                  nil)))
          ;; Kill existing buffer if it exists
          (when (get-buffer buffer-name)
            (kill-buffer buffer-name))
          ;; Create the results buffer
          (with-current-buffer (get-buffer-create buffer-name)
            (read-only-mode -1)
            (erase-buffer)
            (if (not formatted-output)
                (progn
                  (message "Ripgrep finished with errors or no results.")
                  (insert "No results found."))
              (insert formatted-output)
              ;; Highlight the search term
              (let ((case-fold-search t)) ;; Make the highlighting case insensitive
                (goto-char (point-min))
                (while (search-forward search-term nil t)
                  (let ((start (match-beginning 0))
                        (end (match-end 0)))
                    ;; Add an overlay to highlight the match
                    (let ((overlay (make-overlay start end)))
                      (overlay-put overlay 'face '(:background "yellow" :foreground "black"))))))
              (grep-mode)
              (pop-to-buffer buffer-name)
              (goto-char (point-min)))))
      ;; Fall back to rgrep if ripgrep is not available
      (let ((default-directory directory))
        (rgrep search-term glob directory)))))
#+end_src

** DOING find-name-dired

Currently find file type jump key functionality for core is just find-name-dired but probably better to have a more flexible version that can still use =find-name-dired= but if ripgrep exists or even find then present those options.  This will then potentially be a more modern approach.

Being solved with the following code:

#+begin_src elisp
(defun my/find-file ()
  "Find file from current directory in many different ways."
  (interactive)
  (let* ((find-options (delq nil
                             (list (when (executable-find "find")
                                     '("find -type f -printf \"$PWD/%p\\0\"" . :string))
                                   (when (executable-find "fd")
                                     '("fd --absolute-path --type f -0" . :string))
                                   (when (executable-find "rg")
                                     '("rg --follow --files --null" . :string))
                                   (when (fboundp 'find-name-dired)
                                     '("find-name-dired" . :command)))))
         (selection (completing-read "Select: " find-options))
         file-list
         file)
    (pcase (alist-get selection find-options nil nil #'string=)
      (:command
       (call-interactively (intern selection)))
      (:string
       (setq file-list (split-string (shell-command-to-string selection) "\0" t))
       (setq file (completing-read
                   (format "Find file in %s: "
                           (abbreviate-file-name default-directory))
                   file-list))))
    (when file (find-file (expand-file-name file)))))
#+end_src

** DOING magit

Replace by built-in VC

Just need to be able to push using ssh

** TODO selected-window-accent-mode

My package of highlighting the selected window/tabs, which actually I find very useful and of course due to my familiarity I could code up a more simple version.

** TODO htmlize

Go through the Emacs export mechanism instead and open separate browser window, refreshing when exported each time?

** TODO image-dired

Copy over functionality, no real external things, its just is it valuable given how little I use it? 

** TODO tempel

I use pretty simple, no yassnippet complexity here, so maybe I can adapt dabrev with some predefined functions for the most common completion replacements?

** TODO corfu / company completion

Can probably live without, as tab completion is probably fine

** TODO spelling

The core is using hunspell, flyspell which works generally pretty well, libreoffice will pretty much always be available or easily installable so hunspell will probably be always available.

I like jinx as it is fast and efficient.

powerthesaurus I don't use that often.

writegood-mode is a favourite, but I could probably live without it.

** TODO popper

Mainly used for popping and popping out shells, I'm sure I can code up an alternative solution here if I need to.

** TODO shell

Can I bring in cape-history into eshell/shell, the main issue is the inline fish type completion which I may be able to live without, but it is really fast and convenient!

** TODO capf-autosuggest

Some elisp for some simple predictive inline completion, maybe take a look at how capf-autosuggest does it.

** TODO org-capture

I think we can already move to core

** TODO DWIM script integration

Should be almost a straightforward copy, just need to consider which bash scripts I copy across, if any

** TODO org-agenda

I think we can already move to core

** TODO kurecolor

Add some elisp with the requisite regex-search and elisp colour calls, I have achieved this in the past, before I found the more convenient option of kurecolor

** TODO Ada

Unfortunately this may be the only elisp package that I may need to bake into this whole concept.  Current ada-mode isn't supported out of the box in Emacs, it is suggested to use the AdaCore ada-mode but that is a pain to compile (mainly due to trying to install gnatcoll), I have found the old ada mode used by Emacs for that adequate, so this may need to be separately downloaded and baked in.

These is also the potential to use ada-mode-lite and leverage eglot for the rest.

** TODO transients

Convert all transients which rely on Emacs 28 implementation of built-in transients.  The same can be achieved comfortably with a simple menu to stdout and read key type system.

*** TODO my/transient-outlining-and-folding

Transient menu for outline-mode.

*** TODO my/prog-folding

Enable and configure outline minor mode for code folding.  This function sets up the outline minor mode tailored for programming modes based on basic space / tab indentation.

* TODO Features that won't be converted to core

** TODO calendar / calfw

** TODO themes

** TODO ox-hugo

** TODO eglot

Not too much I can do about this, however I could apply some =etag= replacement functionality, but it really isn't the same.
