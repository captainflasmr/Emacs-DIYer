#+title: Emacs Enhanced
#+author: James Dyer
#+options: toc:nil author:t title:t
#+startup: showall
#+todo: TODO DOING | DONE
#+property: header-args :tangle ~/.emacs.d/Emacs-enhanced/init.el

#+begin_src emacs-lisp :exports none
;; -*- lexical-binding: t; -*-
#+end_src

* Introduction

A conversion of major Emacs packages / functions, especially ones that I rely on to single defuns to try avoid the dependence of external packages.

It is also a general comment on how I have moved to more a vanilla based Emacs setup and relying much less on external packages as I think I now have enough elisp knowledge to replace a lot of them!

Perfect for lightweight usage in VMs or basic tasks.

Used in concert with https://github.com/captainflasmr/Emacs-core

* Whats New

** <2025-01-08>

Added open-with replacement using dired.

** <2025-01-07>

Add eglot replacement using custom etags functions and keybindings

- Added `my/etags-load`: Locate and load the nearest TAGS file.
- Added `my/etags-update`: Generate etags using an external script if available.
- Added `my/generate-etags`: Recursively create etags for C, C++, C#, and Ada files.
- Introduced `predicate-exclusion-p` for directory exclusion logic.
- Bound `my/etags-load` to `C-x p l` and `my/etags-update` to `C-x p u`.

** <2025-01-05>

icomplete-in-buffer setup and completion functions to try and replace corfu/company

- Added `(setq icomplete-in-buffer t)` to improve in-buffer completion behavior.
- Documented custom functions =my/simple-completion-at-point= utilizing =completion-in-region= and =completing-read=
- Introduced `C-c TAB` keybinding for invoking custom completion.
- Disabled `completion-auto-help` globally except in minibuffer.
- Customized `TAB` key binding for minibuffer-local-completion-map.
- Suppressed completion buffer help header via `completion-show-help`.
- Updated documentation to reflect these adjustments and their rationale.

** <2025-01-01>

Refactor popup handling and improve buffer filtering logic

- Updated =my/popper-show-hide-popup= to improve popup buffer filtering with =popup-patterns=,
  allowing more flexible matching of buffers against patterns.
- Adjusted logic to remove redundant comments and optimize control flow:
  - Clearly separated cases for hiding the current popup and displaying the next valid popup.
  - Refactored buffer filtering using =seq-filter= to enhance clarity and reduce redundancy.
- Removed extraneous comments and dead code for improved readability.
- No functional changes to existing behavior; this is a refactoring for code clarity and maintainability.

** <2024-12-29>

Added initial attempt at generating an RSS xml feed based on my org posts.

* Kanban

Here is a kanban of the features that will be (hopefully) converted to core/enhanced Emacs features and visually demonstrating their current status via a kanban board

#+begin_src emacs-lisp :results table :exports results :tangle no
(my/kanban-to-table "roadmap" "issues")
#+end_src

#+RESULTS:
| TODO             | DOING                        | DONE                        |
|------------------+------------------------------+-----------------------------|
| capf-autosuggest | consult                      | minibuffer completion       |
|                  | embark                       | ace-window                  |
|                  | popper                       | recentf-open                |
|                  | pandoc md to org conversion  | rainbow-mode                |
|                  | completion - corfu / company | visual-fill-column-mode     |
|                  | org-kanban                   | find-name-dired             |
|                  | ox-hugo                      | magit                       |
|                  | eglot                        | tempel                      |
|                  | open-with                    | image-dired                 |
|                  |                              | selected-window-accent-mode |
|                  |                              | deadgrep                    |
|                  |                              | jinx / powerthesaurus       |
|                  |                              | kurecolor                   |

* Issues

#+begin_src emacs-lisp :results table :exports results :tangle no
(my/collate-issues-into-table)
#+end_src

#+RESULTS:
| TODO  | Title                                     | Parent Title                 |
|-------+-------------------------------------------+------------------------------|
| TODO  | Apply css                                 | ox-hugo                      |
| DOING | Generate RSS xml                          | ox-hugo                      |
| DOING | Test completion through programming modes | completion - corfu / company |
| TODO  | push buffer to popup buffer and back      | popper                       |

* Roadmap                                                           :roadmap:

Here are the features that will be (hopefully) converted to core.

** DONE minibuffer completion

fido-mode enabled replacing:

- vertico
- marginalia
- orderless

but also require the following for exiting a forced completion:

#+begin_src elisp
(defun my-icomplete-exit-minibuffer-with-input ()
  "Exit the minibuffer with the current input, without forcing completion."
  (interactive)
  (exit-minibuffer))
#+end_src

Note that orderless isn't really replaced, I can enable flex but I don't feel I really need the orderless functionality anyway.

** DONE ace-window
CLOSED: [2024-12-08 Sun 13:53]

Solved with the code below:

#+begin_src elisp
(defun my/quick-window-jump ()
  "Jump to a window by typing its assigned character label.
If there is only a single window, split it horizontally.
If there are only two windows, jump directly to the other window."
  (interactive)
  (let* ((window-list (window-list nil 'no-mini)))
    (cond
     ;; If there is only a single window, split it horizontally.
     ((= (length window-list) 1)
      (split-window-horizontally)
      (other-window 1)) ;; Move focus to the new window immediately after splitting.

     ;; If there are only two windows, switch to the other one directly.
     ((= (length window-list) 2)
      (select-window (other-window-for-scrolling)))

     ;; Otherwise, present the key selection interface.
     (t
      (let* ((my/quick-window-overlays nil)
             (sorted-windows (sort window-list
                                   (lambda (w1 w2)
                                     (let ((edges1 (window-edges w1))
                                           (edges2 (window-edges w2)))
                                       (or (< (car edges1) (car edges2))
                                           (and (= (car edges1) (car edges2))
                                                (< (cadr edges1) (cadr edges2))))))))
             (window-keys (seq-take '("j" "k" "l" ";" "a" "s" "d" "f")
                                    (length sorted-windows)))
             (window-map (cl-pairlis window-keys sorted-windows)))
        (setq my/quick-window-overlays
              (mapcar (lambda (entry)
                        (let* ((key (car entry))
                               (window (cdr entry))
                               (start (window-start window))
                               (overlay (make-overlay start start (window-buffer window))))
                          (overlay-put overlay 'after-string 
                                       (propertize (format "[%s]" key)
                                                   'face '(:foreground "white" :background "blue" :weight bold)))
                          (overlay-put overlay 'window window)
                          overlay))
                      window-map))
        (let ((key (read-key (format "Select window [%s]: " (string-join window-keys ", ")))))
          (mapc #'delete-overlay my/quick-window-overlays)
          (setq my/quick-window-overlays nil)
          (when-let ((selected-window (cdr (assoc (char-to-string key) window-map))))
            (select-window selected-window))))))))
#+end_src

** DONE recentf-open
CLOSED: [2024-12-09 Mon 09:22]

Given recentf-open was introduced in 29.1, just copied what has been put into recentf.el for that version!

Solved with the code below:

#+begin_src elisp
(defun my/recentf-open (file)
  "Prompt for FILE in `recentf-list' and visit it.
Enable `recentf-mode' if it isn't already."
  (interactive
   (list
    (progn (unless recentf-mode (recentf-mode 1))
           (completing-read "Open recent file: " recentf-list nil t))))
  (when file
    (funcall recentf-menu-action file)))
#+end_src

** DONE rainbow-mode
CLOSED: [2024-12-09 Mon 10:50]

Solved with the code below:

#+begin_src elisp
(defun my/rainbow-mode ()
  "Overlay colors represented as hex values in the current buffer."
  (interactive)
  (remove-overlays (point-min) (point-max))
  (let ((hex-color-regex "#[0-9a-fA-F]\\{3,6\\}"))
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward hex-color-regex nil t)
        (let* ((color (match-string 0))
               (overlay (make-overlay (match-beginning 0) (match-end 0))))
          (if (string-greaterp color "#888888")
              (overlay-put overlay 'face `(:background ,color :foreground "black"))
            (overlay-put overlay 'face `(:background ,color :foreground "white"))))))))
;;
(defun my/rainbow-mode-clear ()
  "Remove all hex color overlays in the current buffer."
  (interactive)
  (remove-overlays (point-min) (point-max)))
#+end_src

** DONE visual-fill-column-mode
CLOSED: [2024-12-09 Mon 13:50]

Solved with the code below:

#+begin_src elisp
(defun toggle-centered-buffer ()
  "Toggle center alignment of the buffer by adjusting window margins based on the fill-column."
  (interactive)
  (let* ((current-margins (window-margins))
         (margin (if (or (equal current-margins '(0 . 0))
                         (null (car (window-margins))))
                     (/ (- (window-total-width) fill-column) 2)
                   0)))
    (visual-line-mode 1)
    (set-window-margins nil margin margin)))
#+end_src

** DONE find-name-dired
CLOSED: [2024-12-18 Wed 09:27]

Currently, the file type jump key functionality for core is limited to =find-name-dired=. However, it might be better to implement a more flexible version that defaults to =find-name-dired= but also presents additional options if tools like =ripgrep= or =find= are available. This would offer a potentially more modern and versatile approach.

Being solved with the following code:

#+begin_src elisp
(defun my/find-file ()
  "Find file from current directory in many different ways."
  (interactive)
  (let* ((find-options (delq nil
                             (list (when (executable-find "find")
                                     '("find -type f -printf \"$PWD/%p\\0\"" . :string))
                                   (when (executable-find "fd")
                                     '("fd --absolute-path --type f -0" . :string))
                                   (when (executable-find "rg")
                                     '("rg --follow --files --null" . :string))
                                   (when (fboundp 'find-name-dired)
                                     '("find-name-dired" . :command)))))
         (selection (completing-read "Select: " find-options))
         file-list
         file)
    (pcase (alist-get selection find-options nil nil #'string=)
      (:command
       (call-interactively (intern selection)))
      (:string
       (setq file-list (split-string (shell-command-to-string selection) "\0" t))
       (setq file (completing-read
                   (format "Find file in %s: "
                           (abbreviate-file-name default-directory))
                   file-list))))
    (when file (find-file (expand-file-name file)))))
#+end_src

** DONE magit
CLOSED: [2024-12-18 Wed 09:28]

Replaced by built-in VC

Just need to be able to push using ssh

The following instructions seem to work for now, but should really be doing a little better:

Are you getting the following issue when trying to push to github from Emacs in vc-dir mode?
  
#+begin_src 
Running "git push"...
ssh_askpass: exec(/usr/lib/ssh/ssh-askpass): No such file or directory
git@github.com: Permission denied (publickey).
fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.
#+end_src

Well the ssh-askpass is not installed and doesn't exist in =/usr/lib/ssh/ssh-askpass=

Is there a way to point to a different name in Emacs?, not sure

But perform the following as a current workaround
  
Install the following:

=openssh-askpass=

Which make available the following:
  
/usr/bin/qt4-ssh-askpass

Emacs is looking for:

/usr/lib/ssh/ssh-askpass

So why not provide a symbolic link as root!?, seems to work:

#+begin_src 
  su -
  cd /usr/lib/ssh
  ln -s /usr/bin/qt4-ssh-askpass ssh-askpass
#+end_src

Although still raises the following:
  
#+begin_src
  Running "git push"...
  ErrorHandler::Throw - warning: QFSFileEngine::open: No file name specified file:  line: 0 function: 
  To github.com:captainflasmr/Emacs-enhanced.git
  6735e12..4766e6c  main -> main
#+end_src

** DONE tempel
CLOSED: [2024-12-18 Wed 09:26]

I use pretty simple configurations (no yasnippet complexity here) so  adapting abbrev with some predefined functions for the most common completion replacements.

Adapting to use =abbrev-mode=, the syntax for =abbrev_defs= is very similar to Tempel configuration files, making it easy to adapt.

Replaced tempel with abbrev, will have to write a blog post about this but replacing the following tempel template :

#+begin_src fundamental :tangle no
fundamental-mode ;; Available everywhere
;;
(ja (format-time-string "<%Y-%m-%d>"))
(jT (format-time-string "%Y%m%d%H%M%S"))
(jt (format-time-string "%Y%m%d"))
(ji "(interactive)")
(jl "(lambda ()")
;;
org-mode
;;
(jm "#+hugo: more")
(jg "#+attr_org: :width 300px" n "#+attr_html: :width 100%")
(je "#+attr_org: :width 300px" n "#+attr_html: :class emacs-img")
(jo "---" n "#+TOC: headlines 1 local" n "---")
(jk "#+begin: kanban :layout (\"...\" . 40) :scope nil :range (\"TODO\" . \"DONE\") :sort \"O\" :depth 2 :compressed t" n "#+end:")
(jp "~--APT--~ ")
;;
sh-mode
(jd n "echo \"poop: " p "\"" n)
;;
emacs-lisp-mode
(jd n "(message \"poop: " p "\"\)" n)
;;
ada-mode
(jd n> "Ada.Text_Io.Put_Line \( \"poop: " p "\"\);" n)
;;
c++-mode
(jd n> "std::cout << \"poop: " p "\" << std::endl;" n)
;;
c-mode
(jd n> "fprintf(stderr, \"poop: " p "\"\);" n)
#+end_src

with the following abbrev =abbrev_defs=:

#+begin_src fundamental-mode :tangle no
;;-*-coding: utf-8;-*-
(define-abbrev-table 'ada-mode-abbrev-table
  '(
    ("jd" "Ada.Text_Io.Put_Line (\"poop: \");" nil :count 0)
   ))
(define-abbrev-table 'c++-mode-abbrev-table
  '(
    ("jd" "std::cout << \"poop: \" << std::endl;" nil :count 0)
   ))
(define-abbrev-table 'c-mode-abbrev-table
  '(
    ("jd" "printf(stderr, \"poop: \");" nil :count 0)
   ))
(define-abbrev-table 'emacs-lisp-mode-abbrev-table
  '(
    ("jd" "(message \"poop: \")" nil :count 0)
   ))
(define-abbrev-table 'global-abbrev-table
  '(
    ("jT" "" (lambda nil (interactive) (insert (format-time-string "%Y%m%d%H%M%S"))) :count 0)
    ("ja" "" (lambda nil (interactive) (insert (format-time-string "<%Y-%m-%d>"))) :count 1)
    ("ji" "(interactive)" nil :count 1)
    ("jl" "(lambda ()" nil :count 0)
    ("jt" "" (lambda nil (interactive) (insert (format-time-string "%Y%m%d"))) :count 0)
   ))
(define-abbrev-table 'org-mode-abbrev-table
  '(
    ("je" "#+attr_org: :width 300px
,#+attr_html: :class emacs-img" nil :count 0)
    ("jg" "#+attr_org: :width 300px
,#+attr_html: :width 100%" nil :count 0)
    ("jk" "#+begin: kanban :layout (\"...\") :scope nil :range (\"TODO\" . \"DONE\") :sort \"O\" :depth 2 :compressed t
,#+end:" nil :count 0)
    ("jm" "#+hugo: more" nil :count 0)
    ("jo" "---
,#+TOC: headlines 1 local
---" nil :count 0)
    ("jp" "~--APT--~" nil :count 0)
   ))
(define-abbrev-table 'sh-mode-abbrev-table
  '(
    ("jd" "echo \"poop: \"" nil :count 0)
   ))
#+end_src

The only downside is the lack of positional cursor options that are easily defined in Tempel, but if I really wanted to, I could just include lambda functions to move the cursor. However, I don't think I’m too bothered; I’ll just use the usual Emacs navigation keys.

** DONE image-dired
CLOSED: [2024-12-19 Thu 11:44]

This is mainly enhancements to provide a more comfortable Desktop feel to image navigation.

** DONE selected-window-accent-mode
CLOSED: [2024-12-20 Fri 08:53]

My package of highlighting the selected window/tabs, which actually I find very useful and of course due to my familiarity I could code up a more simple version.

Pretty much covered by where the user will be prompted for a colour and the faces adapted accordingly:

#+begin_src elisp
(defun my/sync-tab-bar-to-theme (&optional color)
  "Synchronize tab-bar faces with the current theme, and set
mode-line background color interactively using `read-color`
if COLOR is not provided as an argument."
  (interactive (list (when current-prefix-arg (read-color "Color: "))))
  ;; Determine the color to use
  (let ((selected-color (or color (read-color "Select mode-line background color: "))))
    (set-hl-line-darker-background)
    (set-face-attribute 'mode-line nil :height 120 :underline nil :overline nil :box nil
                        :background selected-color :foreground "#000000")
    (set-face-attribute 'mode-line-inactive nil :height 120 :underline nil :overline nil
                        :background "#000000" :foreground "#aaaaaa")
    (let ((default-bg (face-background 'default))
          (default-fg (face-foreground 'default))
          (default-hl (face-background 'highlight))
          (inactive-fg (face-foreground 'mode-line-inactive)))
      (custom-set-faces
       `(vertical-border ((t (:foreground ,(darken-color default-fg 60)))))
       `(window-divider ((t (:foreground ,(darken-color default-fg 60)))))
       `(fringe ((t (:foreground ,default-bg :background ,default-bg))))
       `(tab-bar ((t (:inherit default :background ,default-bg :foreground ,default-fg))))
       `(tab-bar-tab ((t (:inherit 'highlight :background ,selected-color :foreground "#000000"))))
       `(tab-bar-tab-inactive ((t (:inherit default :background ,default-bg :foreground ,inactive-fg
                                            :box (:line-width 2 :color ,default-bg :style released-button)))))))))
#+end_src

** DONE deadgrep
CLOSED: [2024-12-20 Fri 08:54]

Would rgrep be potentially good enough?, maybe, or perhaps implement ripgrep through a simple interface while reusing `grep-mode`. Essentially, it would look similar to rgrep's output but include more detailed information from the ripgrep search, similar to the style of deadgrep. For example:

- directory
- search term
- glob

And, like deadgrep, have some local keybindings that can input the directory, search term, or glob.

Being solved with the following code:

#+begin_src elisp
(defun my/grep (search-term &optional directory glob)
  "Run ripgrep (rg) with SEARCH-TERM and optionally DIRECTORY and GLOB.
  If ripgrep is unavailable, fall back to Emacs's rgrep command. Highlights SEARCH-TERM in results.
  By default, only the SEARCH-TERM needs to be provided. If called with a
  universal argument, DIRECTORY and GLOB are prompted for as well."
  (interactive
   (let ((univ-arg current-prefix-arg))
     (list
      (read-string "Search for: ")
      (when univ-arg (read-directory-name "Directory: "))
      (when univ-arg (read-string "File pattern (glob, default: ): " nil nil "")))))
  (let* ((directory (expand-file-name (or directory default-directory)))
         (glob (or glob ""))
         (buffer-name "*grep*"))
    (if (executable-find "rg")
        (let* ((rg-command (format "rg --color=never --max-columns=500 --column --line-number --no-heading --smart-case -e %s --glob %s %s"
                                   (shell-quote-argument search-term)
                                   (shell-quote-argument glob)
                                   directory))
               (debug-output (shell-command-to-string (format "rg --debug --files %s" directory)))
               (ignore-files (when (string-match "ignore file: \\(.*?\\.ignore\\)" debug-output)
                               (match-string 1 debug-output)))
               (raw-output (shell-command-to-string rg-command))
               (formatted-output
                (when (not (string-empty-p raw-output))
                  (concat
                   (format "[s] Search:    %s\n[d] Directory: %s\n" search-term directory)
                   (format "[o] Glob:      %s\n" glob)
                   (if ignore-files (format "%s\n" ignore-files) "")
                   "\n"
                   (replace-regexp-in-string (concat "\\(^" (regexp-quote directory) "\\)") "./" raw-output)))))
          (when (get-buffer buffer-name)
            (kill-buffer buffer-name))
          (with-current-buffer (get-buffer-create buffer-name)
            (setq default-directory directory)
            (erase-buffer)
            (insert (or formatted-output "No results found."))
            (insert "\nripgrep finished.")
            (goto-char (point-min))
            (when formatted-output
              (let ((case-fold-search t))
                (while (search-forward search-term nil t)
                  (overlay-put (make-overlay (match-beginning 0) (match-end 0))
                               'face '(:slant italic :weight bold :underline t)))))
            (grep-mode)
            (pop-to-buffer buffer-name)
            (goto-char (point-min))
            (message "ripgrep finished.")))
      (progn
        (setq default-directory directory)
        (message (format "%s : %s : %s" search-term glob directory))
        (rgrep search-term  (if (string= "" glob) "*" glob) directory)))
    (with-current-buffer "*grep*"
      (local-set-key (kbd "d") (lambda () 
                                 (interactive)
                                 (my/grep search-term 
                                          (read-directory-name "New search directory: ")
                                          glob)))
      (local-set-key (kbd "s") (lambda () 
                                 (interactive)
                                 (my/grep (read-string "New search term: ")
                                          directory
                                          glob)))
      (local-set-key (kbd "o") (lambda () 
                                 (interactive)
                                 (my/grep search-term
                                          directory
                                          (read-string "New glob: "))))
      (local-set-key (kbd "g") (lambda () 
                                 (interactive)
                                 (my/grep search-term directory glob))))))
;;
(defun my-org-reveal-on-next-error ()
  "Reveal the location of search results in an Org file."
  (when (derived-mode-p 'org-mode)
    (org-reveal)))
;;
(add-hook 'next-error-hook 'my-org-reveal-on-next-error)
#+end_src

** DONE jinx / powerthesaurus
CLOSED: [2024-12-20 Fri 09:04]

I think I can probably just use =flyspell-buffer=, and do I really need a thesaurus? Probably not, I can just rely on =dictionary-lookup-definition=.

Solution is the following configuration:

#+begin_src elisp
(setq ispell-local-dictionary "en_GB")
(setq ispell-program-name "hunspell")
(setq dictionary-default-dictionary "*")
(setq dictionary-server "dict.org")
(setq dictionary-use-single-buffer t)
(define-prefix-command 'my-spell-prefix-map)
(global-set-key (kbd "C-c s") 'my-spell-prefix-map)
(global-set-key (kbd "C-c s s") #'(lambda()(interactive)
                                    (flyspell-buffer)
                                    (call-interactively 'flyspell-mode)))
(global-set-key (kbd "C-c s d") #'dictionary-lookup-definition)
(global-set-key (kbd "C-0") #'ispell-word)
#+end_src

Note that at the moment, I don't really care about spell-checking efficiency (which Jinx was very good at). I am quite happy to wait a few seconds for the =flyspell-buffer= to run, and in a narrowed region, it won't take that long anyway.

Also, as a bonus, I recently discovered the shortcut key `C-.`, which cycles through autocorrect suggestions for a word. This makes life much simpler.

#+begin_quote
(flyspell-auto-correct-word)

Correct the current word.
This command proposes various successive corrections for the
current word.  If invoked repeatedly on the same position, it
cycles through the possible corrections of the current word.
#+end_quote

** DONE kurecolor
CLOSED: [2024-12-20 Fri 08:54]

I have always found this very useful when customizing my system or webpage to incrementally tweak colours.

Testing with the following code:

#+begin_src elisp
(require 'cl-lib)
(require 'color)
;;
(defun my/color-hex-to-rgb (hex-color)
  "Convert a HEX-COLOR string to a list of RGB values."
  (unless (string-match "^#[0-9a-fA-F]\\{6\\}$" hex-color)
    (error "Invalid hex color: %s" hex-color))
  (mapcar (lambda (x) (/ (string-to-number x 16) 255.0))
          (list (substring hex-color 1 3)
                (substring hex-color 3 5)
                (substring hex-color 5 7))))
;;
(defun my/color-rgb-to-hex (rgb)
  "Convert a list of RGB values to a hex color string."
  (format "#%02x%02x%02x"
          (round (* 255 (nth 0 rgb)))
          (round (* 255 (nth 1 rgb)))
          (round (* 255 (nth 2 rgb)))))
;;
(defun my/color-adjust-brightness (hex-color delta)
  "Adjust the brightness of HEX-COLOR by DELTA (-1.0 to 1.0)."
  (let* ((rgb (my/color-hex-to-rgb hex-color))
         (adjusted-rgb (mapcar (lambda (c) (min 1.0 (max 0.0 (+ c delta)))) rgb)))
    (my/color-rgb-to-hex adjusted-rgb)))
;;
(defun my/color-adjust-saturation (hex-color delta)
  "Adjust the saturation of HEX-COLOR by DELTA (-1.0 to 1.0)."
  (let* ((rgb (my/color-hex-to-rgb hex-color))
         (max (apply 'max rgb))
         (adjusted-rgb (mapcar
                        (lambda (c)
                          (if (= max 0.0)
                              c
                            (+ (* c (- 1 delta)) (* max delta))))
                        rgb)))
    (my/color-rgb-to-hex adjusted-rgb)))
;;
(defun my/color-adjust-hue (hex-color delta)
  "Adjust the hue of HEX-COLOR by DELTA (in degrees)."
  (let* ((rgb (my/color-hex-to-rgb hex-color))
         (hsl (color-rgb-to-hsl (nth 0 rgb) (nth 1 rgb) (nth 2 rgb)))
         (new-h (mod (+ (nth 0 hsl) (/ delta 360.0)) 1.0)) ;; Wrap hue around
         (new-rgb (apply 'color-hsl-to-rgb (list new-h (nth 1 hsl) (nth 2 hsl)))))
    (my/color-rgb-to-hex new-rgb)))
;;
(defun my/replace-color-at-point (transform-fn &rest args)
  "Replace the hex color code at point using TRANSFORM-FN with ARGS."
  (let ((bounds (bounds-of-thing-at-point 'sexp))
        (original (thing-at-point 'sexp t)))
    (if (and bounds (string-match "^#[0-9a-fA-F]\\{6\\}$" original))
        (let ((new-color (apply transform-fn original args)))
          (delete-region (car bounds) (cdr bounds))
          (insert new-color))
      (error "No valid hex color code at point"))))
;;
(global-set-key (kbd "M-<up>") 
                (lambda () 
                  (interactive) 
                  (my/replace-color-at-point 'my/color-adjust-brightness 0.02) 
                  (my/rainbow-mode)))
(global-set-key (kbd "M-<down>") 
                (lambda () 
                  (interactive) 
                  (my/replace-color-at-point 'my/color-adjust-brightness -0.02) 
                  (my/rainbow-mode)))
(global-set-key (kbd "M-<prior>") 
                (lambda () 
                  (interactive) 
                  (my/replace-color-at-point 'my/color-adjust-saturation 0.02) 
                  (my/rainbow-mode)))
(global-set-key (kbd "M-<next>") 
                (lambda () 
                  (interactive) 
                  (my/replace-color-at-point 'my/color-adjust-saturation -0.02) 
                  (my/rainbow-mode)))
(global-set-key (kbd "M-<left>") 
                (lambda () 
                  (interactive) 
                  (my/replace-color-at-point 'my/color-adjust-hue -5) 
                  (my/rainbow-mode)))
(global-set-key (kbd "M-<right>") 
                (lambda () 
                  (interactive) 
                  (my/replace-color-at-point 'my/color-adjust-hue 5) 
                  (my/rainbow-mode)))
(global-set-key (kbd "M-<home>") 'my/insert-random-color-at-point)
#+end_src

** DOING consult

Originally I had the following keybindings mapped :

#+begin_src elisp :tangle no
(global-set-key (kbd "M-g i") 'consult-imenu)
(global-set-key (kbd "M-g o") 'consult-outline)
#+end_src

The first one is easy. I am happy to replace it with =imenu=; the interface brings up a simple minibuffer completing-read. I don't dynamically jump to the headline, but I'm not a fan of that approach anyway.

The second one I think I can replace by using =org-goto= with a couple of tweaks

#+begin_src emacs-lisp
(global-set-key (kbd "M-g o") #'org-goto)
(setq org-goto-interface 'outline-path-completionp)
(setq org-outline-path-complete-in-steps nil)
#+end_src

This transforms the awkward =org-goto= interface into a better, easier, completing-read one, more akin to =consult-outline=.

** DOING embark

I am not using too many aspects mainly the following:

- copy command from the minibuffer
- find file at point

Solved with the code below:

#+begin_src elisp
(defun my-icomplete-copy-candidate ()
  "Copy the current Icomplete candidate to the kill ring."
  (interactive)
  (let ((candidate (car completion-all-sorted-completions)))
    (when candidate
      (kill-new (substring-no-properties candidate))
      (abort-recursive-edit))))
;;
(global-set-key (kbd "C-c ,") 'find-file-at-point)
(define-key minibuffer-local-completion-map (kbd "C-c ,") 'my-icomplete-copy-candidate)
#+end_src
  
collect/export could be solved with a TAB showing completions buffer

** DOING popper

Mainly used for popping and popping out shells, testing the following implementation:

#+begin_src elisp
(defun my/popper-matching-buffers ()
  "Return a list of buffers matching pop-up patterns."
  (let ((popup-patterns '("\\*eshell\.*\\*" "\\*eldoc\.*\\*" "\\*Flymake\.*")))
    (seq-filter (lambda (buf)
                  (let ((bufname (buffer-name buf)))
                    (seq-some (lambda (pattern)
                                (string-match-p pattern bufname))
                              popup-patterns)))
                (buffer-list))))
;;
(defun my/popper-handle-popup (buffer)
  "Display BUFFER as a popup, setting it as the current popup."
  (pop-to-buffer buffer
               '((display-buffer-reuse-window display-buffer-at-bottom)
                 (inhibit-same-window . t)
                 (window-height . 0.3)))
  (message "Displayed pop-up buffer: %s" (buffer-name buffer)))
;;
(defun my/popper-cycle-popup ()
  "Cycle visibility of pop-up buffers."
  (interactive)
  (let* ((popup-buffers (my/popper-matching-buffers))
         (current-popup-window (car (seq-filter (lambda (win)
                                                  (member (window-buffer win) popup-buffers))
                                                (window-list)))))
    (when current-popup-window
      (let ((buf (window-buffer current-popup-window)))
        (delete-window current-popup-window)
        (bury-buffer buf)
        (setq popup-buffers (my/popper-matching-buffers))
        (message "Hid pop-up buffer: %s" (buffer-name buf))))
    (if popup-buffers
        (my/popper-handle-popup (car popup-buffers))
      (message "No pop-up buffers to display!"))))
;;
(defun my/popper-toggle-current ()
  "Toggle visibility of pop-up buffers."
  (interactive)
  (let* ((popup-buffers (my/popper-matching-buffers))
         (current-popup-window (car (seq-filter (lambda (win)
                                                  (member (window-buffer win) popup-buffers))
                                                (window-list)))))
    (if current-popup-window
        (let ((buf (window-buffer current-popup-window)))
          (delete-window current-popup-window)
          (message "Hid pop-up buffer: %s" (buffer-name buf)))
      (if popup-buffers
          (my/popper-handle-popup (car popup-buffers))
        (message "No pop-up buffers to display!")))))
;;
;; Cycle through popups or show the next popup.
(global-set-key (kbd "M-'") #'my/popper-cycle-popup)
;;
;; Toggle the currently selected popup.
(global-set-key (kbd "M-;") #'my/popper-toggle-current)
#+end_src

*** TODO push buffer to popup buffer and back                      :issues:

** DOING pandoc md to org conversion

Replacing the external tool Pandoc for converting Markdown (md) to Org format is especially useful when copying and pasting from AI chats.

Potentially solved with the following, probably requires more testing:

#+begin_src elisp
(defun my/md-to-org-convert-buffer ()
  "Convert the current buffer from Markdown to Org-mode format"
  (interactive)
  (save-excursion
    ;; Lists: Translate `-`, `*`, or `+` lists to Org-mode lists
    (goto-char (point-min))
    (while (re-search-forward "^\\([ \t]*\\)[*-+] \\(.*\\)$" nil t)
      (replace-match (concat (match-string 1) "- \\2")))
    ;; Bold: `**bold**` -> `*bold*` only if directly adjacent
    (goto-char (point-min))
    (while (re-search-forward "\\*\\*\\([^ ]\\(.*?\\)[^ ]\\)\\*\\*" nil t)
      (replace-match "*\\1*"))
    ;; Italics: `_italic_` -> `/italic/`
    (goto-char (point-min))
    (while (re-search-forward "\\b_\\([^ ]\\(.*?\\)[^ ]\\)_\\b" nil t)
      (replace-match "/\\1/"))
    ;; Links: `[text](url)` -> `[[url][text]]`
    (goto-char (point-min))
    (while (re-search-forward "\\[\\(.*?\\)\\](\\(.*?\\))" nil t)
      (replace-match "[[\\2][\\1]]"))
    ;; Code blocks: Markdown ```lang ... ``` to Org #+begin_src ... #+end_src
    (goto-char (point-min))
    (while (re-search-forward "```\\(.*?\\)\\(?:\n\\|\\s-\\)\\(\\(?:.\\|\n\\)*?\\)```" nil t)
      (replace-match "#+begin_src \\1\n\\2#+end_src"))
    ;; Inline code: `code` -> =code=
    (goto-char (point-min))
    (while (re-search-forward "`\\(.*?\\)`" nil t)
      (replace-match "=\\1="))
    ;; Horizontal rules: `---` or `***` -> `-----`
    (goto-char (point-min))
    (while (re-search-forward "^\\(-{3,}\\|\\*{3,}\\)$" nil t)
      (replace-match "-----"))
    ;; Images: `![alt text](url)` -> `[[url]]`
    (goto-char (point-min))
    (while (re-search-forward "!\\[.*?\\](\\(.*?\\))" nil t)
      (replace-match "[[\\1]]"))
    (goto-char (point-min))
    ;; Headers: Adjust '#'
    (while (re-search-forward "^\\(#+\\) " nil t)
      (replace-match (make-string (length (match-string 1)) ?*) nil nil nil 1))))
;;
(defun my/md-to-org-convert-file (input-file output-file)
  "Convert a Markdown file INPUT-FILE to an Org-mode file OUTPUT-FILE."
  (with-temp-buffer
    (insert-file-contents input-file)
    (md-to-org-convert-buffer)
    (write-file output-file)))
;;
(defun my/convert-markdown-clipboard-to-org ()
  "Convert Markdown content from clipboard to Org format and insert it at point."
  (interactive)
  (let ((markdown-content (current-kill 0))
        (original-buffer (current-buffer)))
    (with-temp-buffer
      (insert markdown-content)
      (my/md-to-org-convert-buffer)
      (let ((org-content (buffer-string)))
        (with-current-buffer original-buffer
          (insert org-content))))))
;;
(defun my/org-promote-all-headings (&optional arg)
  "Promote all headings in the current Org buffer along with their subheadings."
  (interactive "p")
  (org-map-entries
   (lambda () 
     (dotimes (_ arg) (org-promote)))))
#+end_src

** DOING completion - corfu / company

Can these in buffer completion systems be replaced by a simple in-built =icomplete= solution?

Lets give it a go!

#+begin_src elisp
(define-key icomplete-minibuffer-map (kbd "C-n") #'icomplete-forward-completions)
(define-key icomplete-minibuffer-map (kbd "C-p") #'icomplete-backward-completions)
(define-key icomplete-minibuffer-map (kbd "RET") #'icomplete-force-complete-and-exit)
(add-hook 'after-init-hook (lambda () (fido-mode 1)))
(setq completion-styles '(flex basic substring))
(setq tab-always-indent t)
(setq icomplete-delay-completions-threshold 0)
(setq icomplete-max-delay-chars 0)
(setq icomplete-compute-delay 0)
(setq icomplete-show-matches-on-no-input t)
(setq icomplete-separator " | ")
(add-hook 'buffer-list-update-hook
          (lambda ()
            (unless (minibufferp)
              (setq-local icomplete-separator "\n"))))
(setq icomplete-in-buffer t)
(setq completion-auto-help nil)
(define-key minibuffer-local-completion-map (kbd "TAB")
            (lambda ()
              (interactive)
              (let ((completion-auto-help t))
                (minibuffer-complete))))
(setq completion-show-help nil)
(setq icomplete-with-completion-tables t)
(setq icomplete-prospects-height 2)
(setq icomplete-scroll t)
#+end_src

Note that the =completion-styles= variable is globally set to include =flex= because, by default, Icomplete is the completion engine that operates in the buffer. Since Fido mode, which is enabled by default, does not support /flex/ (something I have now grown accustomed to), this adjustment is necessary.

Also note that when =completion-in-buffer= is turned on I have globally turned off the display of the *Completions* buffer through =completion-auto-help= except in the minibuffer as sometimes I would like to bring up the full list of completions, like maybe embark collect or export.

Note that setting =completion-auto-help= to nil means the help header in the completions buffer will not be shown, which helps to tidy things up.

Note that the =buffer-list-update-hook= allows for vertical Icomplete completion in the buffer! Of course, "\n" could generally be globally enabled if you would like simple Icomplete vertical completion, but I prefer vertical completion only in the buffer, as with Corfu or Company.

Note that =icomplete-prospects-height= allows for a form of in-buffer candidate height adjustment, but it is not an exact solution since the height is based on a horizontal setup. However, it does provide some level of control. Here, I have explicitly set it as a global setting, but in-buffer vertical completion can be tailored accordingly.

As another option, how about a simple defun leveraging =completion-in-region= or =completing-read= :

#+begin_src elisp
(defun my/simple-completion-at-point ()
  "Use completing-read-in-buffer for completion at point."
  (interactive)
  (let* ((completion-data (run-hook-with-args-until-success 
                           'completion-at-point-functions))
         (beg (nth 0 completion-data))
         (end (nth 1 completion-data))
         (table (nth 2 completion-data))
         (pred (plist-get (nthcdr 3 completion-data) :predicate))
         (prefix (buffer-substring-no-properties beg end))
         (completion (completing-read-default
                      "Complete: "
                      table
                      pred
                      nil  ; no require-match
                      prefix)))
    (when completion
      (delete-region beg end)
      (insert completion))))
;;
(global-set-key (kbd "C-c TAB") #'my/simple-completion-at-point)
#+end_src

*** DOING Test completion through programming modes                :issues:

** DOING org-kanban

Creating a Kanban board for an org file: technically, I should just be able to define a =defun= that can be embedded within something like:

#+begin_src emacs-lisp :results table :exports results :tangle no
(my/kanban-to-table "roadmap")
#+end_src

Here is the current code, undergoing testing:

#+begin_src elisp
(defun my/kanban-to-table (&optional match exclude-tag)
  "Format Org headings into a Kanban-style Org table, filtering by MATCH and excluding EXCLUDE-TAG."
  (interactive)
  (let ((todo-states org-todo-keywords-1)
        (kanban-table (list))
        (column-data (make-hash-table :test 'equal)))
    (dolist (state todo-states)
      (puthash state '() column-data))
    (save-excursion
      (goto-char (point-min))
      (org-map-entries
       (lambda ()
         (let* ((todo (org-get-todo-state))
                (heading (org-get-heading t t t t))
                (tags (org-get-tags))) ;; Get tags for current heading.
           (when (and todo (not (string-empty-p todo))
                      (not (member exclude-tag tags))) ;; Exclude headings with the `exclude-tag`.
             (puthash todo
                      (append (gethash todo column-data) (list heading))
                      column-data))))
       match 'file))
    ;; Filter out empty columns
    (setq todo-states (seq-filter (lambda (state)
                                    (not (null (gethash state column-data))))
                                  todo-states))
    ;; Build the rows for the Kanban Org table.
    (let ((max-rows 0))
      (dolist (state todo-states)
        (let ((headings (gethash state column-data)))
          (setq max-rows (max max-rows (length headings)))
          (push (list state headings) kanban-table)))
      ;; Construct the table rows.
      (let ((rows '()))
        ;; Fill rows by extracting each heading under TODO states.
        (dotimes (i max-rows)
          (let ((row '()))
            (dolist (state todo-states)
              (let ((headings (gethash state column-data)))
                (push (or (nth i headings) "") row))) ;; Add the heading or an empty string.
            (push (reverse row) rows)))
        (setq rows (nreverse rows))
        (push 'hline rows)
        ;; Insert TODO column headers at the top.
        (push todo-states rows)))))
#+end_src

** DOING ox-hugo

Lets try and see how far we can get going through the =org-publish= mechanism for publishing a web-site!

#+begin_src elisp
(require 'ox-publish)
;;
(setq org-publish-project-alist
      '(("split-emacs"
         :base-directory "~/DCIM/content"
         :base-extension "org"
         :publishing-directory "~/DCIM/content/split/emacs"
         :exclude ".*"
         :include ("emacs--all.org")
         :publishing-function my-org-publish-split-headings
         :recursive nil)
        ("blog-posts-emacs"
         :base-directory "~/DCIM/content/split/emacs"
         :base-extension "org"
         :publishing-directory "~/publish/hugo-emacs/site/static/public_html"
         :publishing-function org-html-publish-to-html
         :recursive t
         :section-numbers nil
         :with-toc nil
         :html-preamble t
         :html-postamble t
         :auto-sitemap t
         :sitemap-filename "index.org"
         :sitemap-title "the DyerDwelling"
         :html-head "<link rel=\"stylesheet\"
                    href=\"../assets/css//bootstrap.css\"
                    type=\"text/css\"/>\n
                    <link rel=\"stylesheet\"
                    href=\"../assets/css//style-ignore.css\"
                    type=\"text/css\"/>"
         :sitemap-function my-sitemap-format
         :sitemap-sort-files alphabetically)
        ("images-emacs"
         :base-directory "~/DCIM/content/emacs"
         :base-extension "jpg\\|gif\\|png"
         :recursive t
         :publishing-directory "~/publish/hugo-emacs/site/static/public_html/emacs"
         :publishing-function org-publish-attachment)
        ("blog" ;; Meta-project to combine phases
         :components ("split-emacs" "images-emacs" "blog-posts-emacs"))))
;;
(defun my-org-publish-split-headings (plist filename pub-dir)
  "Split an Org file into separate files, each corresponding to a top-level heading
that is marked as DONE.

Each file name is prefixed with the date in YYYYMMDD format extracted from the
:EXPORT_HUGO_LASTMOD: property. PLIST is the property list for the publishing
process, FILENAME is the input Org file, and PUB-DIR is the publishing directory."
  (with-temp-buffer
    (insert-file-contents filename) ;; Load the content of the current Org file
    (goto-char (point-min))
    (let ((heading-level 1) ;; Level of the top-level heading to split by
          prev-start heading-title sanitized-title output-file lastmod-date)
      ;; Iterate over all top-level headings
      (while (re-search-forward (format "^\\*\\{%d\\} \\(?:\\([[:upper:]]+\\) \\)?\\(.*\\)" heading-level) nil t)
        (let ((todo-keyword (match-string 1)) ;; Extract the TODO keyword (if it exists)
              (heading-title (match-string 2))) ;; Extract the title of the heading
          ;; Process only headings marked as DONE
          (when (and todo-keyword (string-equal todo-keyword "DONE"))
            (setq prev-start (match-beginning 0)) ;; Start of the current heading
            (setq sanitized-title (when heading-title
                                    (replace-regexp-in-string "[^a-zA-Z0-9_-]" "_" heading-title))) ;; Sanitize title
            ;; Extract the :EXPORT_HUGO_LASTMOD: property for the current section
            (save-excursion
              (when (re-search-forward ":EXPORT_HUGO_LASTMOD: +\\(<.+>\\)" (save-excursion (re-search-forward "^\\* " nil t) (point)) t)
                (let* ((raw-lastmod (match-string 1)) ;; Extract the timestamp string (e.g., "<2024-12-08 08:37>")
                       (date-elements (when (string-match "<\\([0-9]+\\)-\\([0-9]+\\)-\\([0-9]+\\)" raw-lastmod)
                                        (list (match-string 1 raw-lastmod) ;; Year
                                              (match-string 2 raw-lastmod) ;; Month
                                              (match-string 3 raw-lastmod))))) ;; Day
                  (setq lastmod-date (when date-elements
                                       (apply #'concat date-elements))))))
            ;; Default to "00000000" if no valid lastmod-date is found
            (setq lastmod-date (or lastmod-date "00000000"))
            ;; Find the end of this section (right before the next top-level heading)
            (let ((section-end (save-excursion
                                 (or (re-search-forward (format "^\\*\\{%d\\} " heading-level) nil t)
                                     (point-max))))) ;; End of current section or end of file
              ;; Only proceed if sanitized title exists and is valid
              (when (and sanitized-title (not (string-empty-p sanitized-title)))
                ;; Create the output file name (prepend the date)
                (setq output-file (expand-file-name (format "%s-%s.org" lastmod-date sanitized-title) pub-dir))
                ;; Write the section content (from prev-start to section-end)
                (write-region prev-start section-end output-file)
                (message "Wrote %s" output-file)))))))
    ;; Return nil to indicate successful processing
    nil))
;;
(defun my-sitemap-format (title list)
  "Generate a sitemap with TITLE and reverse-sorted LIST of files."
  (setq list (nreverse (cdr list)))
  (concat "#+TITLE: " title "\n\n"
          "* Blog Posts\n"
          (mapconcat
           (lambda (entry)
             (format "- %s\n" (car entry)))
           list)
          "\n"))
#+end_src

*** DOING Generate RSS xml                                         :issues:

Starting with the following and adapting, it is a decent starting point:

#+begin_src elisp
(defun my-generate-rss-feed ()
  "Generate a detailed RSS feed for Org-published blog posts."
  (interactive)
  (let* ((rss-file (expand-file-name "index.xml" "/home/jdyer/publish/hugo-emacs/site/static/public_html"))
         (base-url "https://www.emacs.dyerdwelling.family/public_html/")
         (self-link "https://www.emacs.dyerdwelling.family/public_html/index.xml") ;; Self-referencing link for Atom feeds
         (last-build-date (format-time-string "%a, %d %b %Y %H:%M:%S %z")) ;; Current time as lastBuildDate
         (org-directory "/home/jdyer/source/test/elisp")
         (static-author "captainflasmr@gmail.com (James Dyer)") ;; Static author 
         ;; (org-directory "/home/jdyer/DCIM/content/split/emacs")
         (rss-items ""))
    ;; Iterate over all Org files in the directory
    (dolist (org-file (directory-files org-directory t "\\.org$"))
      (let* ((html-file (concat (file-name-sans-extension
                                 (file-name-nondirectory org-file)) ".html"))
             (url (concat base-url html-file))
             (heading-level 1)
             (guid url) ;; Default GUID as the post URL
             title
             content
             html-content
             raw-pubdate
             pubdate)
        ;; Read and process the org file
        (with-temp-buffer
          (insert-file-contents org-file)
          (goto-char (point-min))
          ;; Extract the title from the first heading
          (when  (re-search-forward (format "^\\*\\{%d\\} \\(?:\\([[:upper:]]+\\) \\)?\\(.*\\)" heading-level) nil t)
            (setq title (match-string 2)))
          ;; Extract the :EXPORT_HUGO_LASTMOD: property value
          (when (re-search-forward "^.*EXPORT_HUGO_LASTMOD: *<\\([^>]+\\)>" nil t)
            (setq raw-pubdate (match-string 1)))
          ;; Convert the raw-pubdate to the RFC 822 format for <pubDate>
          (when raw-pubdate
            (setq pubdate (format-time-string
                           "%a, %d %b %Y %H:%M:%S %z"
                           (org-time-string-to-time (concat "<" raw-pubdate ">")))))
          ;; Move to the end of :END: and extract the remaining contents
          (when (re-search-forward "^:END:\n" nil t)
            (setq content (buffer-substring-no-properties (point) (point-max)))
            ;; Convert the content to HTML
            (setq html-content (org-export-string-as content 'html t '(:with-toc nil)))
            ;; (setq html-content (xml-escape-string html-content))
            ))
        ;; Add an item to the RSS feed
        (setq rss-items
              (concat rss-items (format "
<item>
  <title>%s</title>
  <link>%s</link>
  <guid>%s</guid>
  <pubDate>%s</pubDate>
  <author>%s</author>
  <description><![CDATA[%s]]></description>
</item>"
                                        (or title "Untitled Post")
                                        url
                                        guid ;; Use the generated GUID
                                        (or pubdate last-build-date) ;; Fallback to lastBuildDate if missing
                                        static-author ;; Static author name
                                        (or html-content "No content available"))))))
    ;; Write the RSS feed to the file
    (with-temp-file rss-file
      (insert "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>
<rss version=\"2.0\" xmlns:atom=\"http://www.w3.org/2005/Atom\">
<channel>
  <title>Emacs@Dyerdwelling</title>
  <image>
      <url>/images/banner/favicon-james.png</url>
      <title>Emacs@Dyerdwelling</title>
      <link>https://emacs.dyerdwelling.family/public_html/</link>
      <width>32</width>
      <height>32</height>
  </image>
  <link>" base-url "</link>
  <description>Recent content on Emacs@Dyerdwelling</description>
  <language>en</language>
  <managingEditor>captainflasmr@gmail.com (James Dyer)</managingEditor>
  <webMaster>captainflasmr@gmail.com (James Dyer)</webMaster>
  <lastBuildDate>" last-build-date "</lastBuildDate>
  <atom:link href=\"" self-link "\" rel=\"self\" type=\"application/rss+xml\" />"
  rss-items "
</channel>
</rss>"))
    (message "RSS feed generated at %s" rss-file)))
#+end_src

*** TODO Apply css                                                 :issues:

** DOING eglot

Note: a more modern version would have eglot built-in (29.1)

In the mean time lets leverage etags as much as possible, initially a bash script to generate a TAGS file for as many programming language extensions possible:

#+begin_src bash :tangle no
#!/bin/bash
TAGF=$PWD/TAGS
rm -f "$TAGF"
for src in `find $PWD \( -path \*/.cache -o \
               -path \*/.gnupg -o \
               -path \*/.local -o \
               -path \*/.mozilla -o \
               -path \*/.thunderbird -o \
               -path \*/.wine -o \
               -path \*/Games -o \
               -path \*/cache -o \
               -path \*/chromium -o \
               -path \*/elpa -o \
               -path \*/nas -o \
               -path \*/syncthing -o \
               -path \*/Image-Line -o \
               -path \*/.cargo -o \
               -path \*/.git -o \
               -path \*/.svn -o \
               -path \*/.themes -o \
               -path \*/themes -o \
               -path \*/objs -o \
               -path \*/ArtRage \) \
               -prune -o -type f -print`;
do
    case "${src}" in
        ,*.ad[absm]|*.[CFHMSacfhlmpsty]|*.def|*.in[cs]|*.s[as]|*.src|*.cc|\
            ,*.hh|*.[chy]++|*.[ch]pp|*.[chy]xx|*.pdb|*.[ch]s|*.[Cc][Oo][Bb]|\
            ,*.[eh]rl|*.f90|*.for|*.java|*.[cem]l|*.clisp|*.lisp|*.[Ll][Ss][Pp]|\
            [Mm]akefile*|*.pas|*.[Pp][LlMm]|*.psw|*.lm|*.pc|*.prolog|*.oak|\
            ,*.p[sy]|*.sch|*.scheme|*.[Ss][Cc][Mm]|*.[Ss][Mm]|*.bib|*.cl[os]|\
            ,*.ltx|*.sty|*.TeX|*.tex|*.texi|*.texinfo|*.txi|*.x[bp]m|*.yy|\
            ,*.[Ss][Qq][Ll])
            etags --append "${src}" -o "$TAGF";
            echo ${src}
            ;;
        ,*)
            FTYPE=`file ${src}`;
            case "${FTYPE}" in
                ,*script*text*)
                    etags --append "${src}" -o "$TAGF";
                    echo ${src}
                    ;;
                ,*text*)
                    if head -n1 "${src}" | grep '^#!' >/dev/null 2>&1;
                    then
                        etags --append "${src}" -o "$TAGF";
                        echo ${src}
                    fi;
                    ;;
            esac;
            ;;
    esac;
done
echo
echo "Finished!"
echo
#+end_src

or maybe the more elisp based approach:

#+begin_src elisp
(defun my/etags-load ()
  "Load TAGS file from the first it can find up the directory stack."
  (interactive)
  (let ((my-tags-file (locate-dominating-file default-directory "TAGS")))
    (when my-tags-file
      (message "Loading tags file: %s" my-tags-file)
      (visit-tags-table my-tags-file))))
;;
(when (executable-find "my-generate-etags.sh")
  (defun my/etags-update ()
    "Call external bash script to generate new etags for all languages it can find."
    (interactive)
    (async-shell-command "my-generate-etags.sh" "*etags*")))
;;
(defun predicate-exclusion-p (dir)
  "exclusion of directories"
  (not
   (or
    (string-match "/home/jdyer/examples/CPPrograms/nil" dir)
    )))
;;
(defun my/generate-etags ()
  "Generate TAGS file for various source files in `default-directory` and its subdirectories."
  (interactive)
  (message "Getting file list...")
  (let ((all-files
         (append
          (directory-files-recursively default-directory "\\(?:\\.cpp$\\|\\.c$\\|\\.h$\\)" nil 'predicate-exclusion-p)
          (directory-files-recursively default-directory "\\(?:\\.cs$\\|\\.cs$\\)" nil 'predicate-exclusion-p)
          (directory-files-recursively default-directory "\\(?:\\.ads$\\|\\.adb$\\)" nil 'predicate-exclusion-p)))
        (tags-file-path (expand-file-name (concat default-directory "TAGS"))))
    (unless (file-directory-p default-directory)
      (error "Default directory does not exist: %s" default-directory))
    ;; Generate TAGS file
    (dolist (file all-files)
      (message file)
      (shell-command (format "etags --append \%s -o %s" file tags-file-path)))))
(global-set-key (kbd "C-x p l") 'my/etags-load)
(global-set-key (kbd "C-x p u") 'my/etags-update)
#+end_src

** DOING open-with

Opening a file, generally from dired, a solution as below:

#+begin_src elisp
(with-eval-after-load 'dired
  (define-key dired-mode-map (kbd "W") 'dired-do-async-shell-command)
  (setq dired-guess-shell-alist-user
        '(("\\.\\(jpg\\|jpeg\\|png\\|gif\\|bmp\\)$" "gthumb")
          ("\\.\\(mp4\\|mkv\\|avi\\|mov\\|wmv\\|flv\\|mpg\\)$" "mpv")
          ("\\.\\(mp3\\|wav\\|ogg\\|\\)$" "mpv")
          ("\\.\\(kra\\)$" "org.kde.krita")
          ("\\.\\(xcf\\)$" "gimp")
          ("\\.\\(odt\\|ods\\|doc\\|docx\\)$" "libreoffice")
          ("\\.\\(html\\|htm\\)$" "firefox")
          ("\\.\\(pdf\\|epub\\)$" "xournalpp"))))
#+end_src

** TODO capf-autosuggest

Some elisp for some simple predictive inline completion, maybe take a look at how capf-autosuggest does it or the new completion preview in Emacs 30.
